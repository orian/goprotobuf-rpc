// Copyright 2013 <chaishushan{AT}gmail.com>. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package generator

import (
	descriptor "code.google.com/p/goprotobuf/protoc-gen-go/descriptor"
	stdgen "code.google.com/p/goprotobuf/protoc-gen-go/generator"
)

// servicePlugin produce the Service interface.
type servicePlugin struct {
	*stdgen.Generator
}

// Name returns the name of the plugin.
func (p *servicePlugin) Name() string { return "ServiceInterface" }

// Init is called once after data structures are built but before
// code generation begins.
func (p *servicePlugin) Init(g *stdgen.Generator) {
	p.Generator = g
}

// Generate produces the code generated by the plugin for this file.
func (p *servicePlugin) GenerateImports(file *stdgen.FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	if len(file.Service) > 0 {
		p.P(`import "io"`)
		p.P(`import "net"`)
		p.P(`import "net/rpc"`)
		p.P(`import "github.com/orian/goprotobuf-rpc/protorpc"`)
	}
}

// Generate generates the Service interface.
func (p *servicePlugin) Generate(file *stdgen.FileDescriptor) {
	if !p.getGenericServicesOptions(file) {
		return
	}
	for _, svc := range file.Service {
		p.genServiceInterface(svc)
		p.genServiceServer(svc)
		p.genServiceClient(svc)
	}
}

func (p *servicePlugin) getGenericServicesOptions(file *stdgen.FileDescriptor) bool {
	if file.Options.GetCcGenericServices() {
		return true
	}
	if file.Options.GetJavaGenericServices() {
		return true
	}
	if file.Options.GetPyGenericServices() {
		return true
	}
	return false
}

func (p *servicePlugin) genServiceInterface(svc *descriptor.ServiceDescriptorProto) {
	name := stdgen.CamelCase(*svc.Name)

	// type {Service} interface
	p.P("type ", name, " interface {")
	p.In()
	for _, m := range svc.Method {
		method := stdgen.CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)
		p.P(method, "(in *", p.TypeName(iType), ", out *", p.TypeName(oType), ") error")
	}
	p.Out()
	p.P("}")
}

func (p *servicePlugin) genServiceServer(svc *descriptor.ServiceDescriptorProto) {
	name := stdgen.CamelCase(*svc.Name)

	// func Register{Service}(srv *rpc.Server, x {Service}) error
	p.P("// Register", name, " publish the given ", name, " implementation on the server.")
	p.P("func Register", name, "(srv *rpc.Server, x ", name, ") error {")
	p.In()
	p.P(`if err := srv.RegisterName("`, name, `", x); err != nil {`)
	p.In()
	p.P("return err")
	p.Out()
	p.P("}")
	p.P("return nil")
	p.Out()
	p.P("}")

	// func Serve{Service}(conn io.ReadWriteCloser, x EchoService) error
	p.P("// Serve", name, " serves the given ", name, " implementation on conn.")
	p.P("func Serve", name, "(conn io.ReadWriteCloser, x ", name, ") error {")
	p.In()
	p.P("srv := rpc.NewServer()")
	p.P(`if err := srv.RegisterName("`, name, `", x); err != nil {`)
	p.In()
	p.P("return err")
	p.Out()
	p.P("}")
	p.P("srv.ServeCodec(protorpc.NewServerCodec(conn))")
	p.P("return nil")
	p.Out()
	p.P("}")

	// func ListenAndServe{Service}(network, addr string, x EchoService) error
	p.P("// ListenAndServe", name, " listen announces on the local network address laddr")
	p.P("// and serves the given ", name, " implementation.")
	p.P("func ListenAndServe", name, "(network, addr string, x ", name, ") error {")
	p.In()
	p.P(`clients, err := net.Listen(network, addr)`)
	p.P("if err != nil {")
	p.In()
	p.P("return err")
	p.Out()
	p.P("}")
	p.P("srv := rpc.NewServer()")
	p.P(`if err := srv.RegisterName("`, name, `", x); err != nil {`)
	p.In()
	p.P("return err")
	p.Out()
	p.P("}")
	p.P("for {")
	p.In()
	p.P("conn, err := clients.Accept()")
	p.P("if err != nil {")
	p.In()
	p.P("return err")
	p.Out()
	p.P("}")
	p.P("go srv.ServeCodec(protorpc.NewServerCodec(conn))")
	p.Out()
	p.P("}")
	p.P(`panic("unreachable")`)
	p.Out()
	p.P("}")
}

func (p *servicePlugin) genServiceClient(svc *descriptor.ServiceDescriptorProto) {
	name := stdgen.CamelCase(*svc.Name)

	// type rpc{Service}Stub struct {
	p.P("type rpc", name, "Stub struct {")
	p.In()
	p.P("*rpc.Client")
	p.Out()
	p.P("}")

	// rpc{Service}Stub method
	for _, m := range svc.Method {
		method := stdgen.CamelCase(*m.Name)
		iType := p.ObjectNamed(*m.InputType)
		oType := p.ObjectNamed(*m.OutputType)
		p.P("func (c *rpc", name, "Stub) ", method, "(in *", p.TypeName(iType), ", out *", p.TypeName(oType), ") error {")
		p.In()
		p.P(`return c.Call("`, name, ".", method, `", in, out)`)
		p.Out()
		p.P("}")
	}

	// func Dial{Service}(addr string) (*rpc.Client, {Service}, error) {
	p.P("// Dial", name, " connects to an ", name, " at the specified network address.")
	p.P("func Dial", name, "(network, addr string) (*rpc.Client, ", name, ", error) {")
	p.In()
	p.P(`conn, err := net.Dial(network, addr)`)
	p.P("if err != nil {")
	p.In()
	p.P("return nil, nil, err")
	p.Out()
	p.P("}")
	p.P("c, srv := New", name, "Client(conn)")
	p.P("return c, srv, nil")
	p.Out()
	p.P("}")

	// func New{Service}Client(conn io.ReadWriteCloser) (*rpc.Client, {Service})
	p.P("// New", name, "Client returns a ", name, " rpc.Client and stub to handle")
	p.P("// requests to the set of ", name, " at the other end of the connection.")
	p.P("func New", name, "Client(conn io.ReadWriteCloser) (*rpc.Client, ", name, ") {")
	p.In()
	p.P("c := rpc.NewClientWithCodec(protorpc.NewClientCodec(conn))")
	p.P("return c, &rpc", name, "Stub{c}")
	p.Out()
	p.P("}")

	// func New{Service}Stub(c *rpc.Client) {Service}
	p.P("// New", name, "Stub returns a ", name, " stub to handle rpc.Client.")
	p.P("func New", name, "Stub(c *rpc.Client) ", name, " {")
	p.Out()
	p.P("return &rpc", name, "Stub{c}")
	p.In()
	p.P("}")
}

func init() {
	stdgen.RegisterPlugin(new(servicePlugin))
}
